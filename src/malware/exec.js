// import { functionName, functionName2 } from "./utils.js"
// RAM 2.90 GB (base, exec)

/* exec: execute multiple single-threaded scripts in parallel rather than 
 * execute one multi-threaded script. 
 * syntax: exec.js --script --host --threads --iterations --args=[]"
 */

/** @param {NS} ns **/
export async function main(ns) {

    const args = ns.flags([
        ['script', ""], 
        ['host', ""], 
        ['threads', 1],
        ['args', []], 
        ['argstring', ""],
    ]);
    const script = args.script;
    const host = args.host;
    const threads = args.threads;
    const script_args = JSON.parse(args.args); // errors if undefined
    const script_argstring = args.argstring;
    //const script_argstring = script_args.join(' ');
        
    var start = performance.now();
    ns.print('ns.args raw args passed in');
    ns.print(ns.args);
    ns.print('--args');
    ns.print(script_args);
    ns.print(typeof script_args);
    ns.print(script_args.join(' '));
    ns.print('--argstring');
    ns.print(script_argstring);
    ns.print(typeof script_argstring);
    ns.print('args._ raw unnamed args passed in');
    ns.print(args._);

    // need to pass script args as space separated 

    for(let t=1;t<=threads;t++) {        
        //ns.exec(script, host, 1, `${script_argstring}`, t);
        ns.exec(script, host, 1, `${script_args.join(' ')}`, t);

    }



    /*
    for(let t=1;t<=2;t++) {        
        ns.exec(filename, "n00dles", 1, targetHost, i, t);
    }
    for(let t=1;t<=3;t++) {        
        ns.exec(filename, "home", 1, targetHost, i, t);
    }


    
    /* 
     * foodnstuff can spawn 9 threads
     * n00dles can spawn 2 threads
     * home can spawn 4 threads (if we re-run after spawning )
     */  
    /*
    let i = 2; // iterations
    for(let t=1;t<=9;t++) {        
        ns.exec(filename, "foodnstuff", 1, targetHost, i, t);
    }
    for(let t=1;t<=2;t++) {        
        ns.exec(filename, "n00dles", 1, targetHost, i, t);
    }
    for(let t=1;t<=3;t++) {        
        ns.exec(filename, "home", 1, targetHost, i, t);
    }
    /* 
     * do <something> while waiting for scripts to finish
     * a grow or weaken perhaps? but they take FOUR times longer
     */
    // await ns.sleep(60000);

    // check if we hit level 5 and can change target server...
    // getPlayer costs 0.5 GB
    // hackingLevel costs 0.05 GB
    //    var hackSkill = ns.getPlayer().skills.hacking;
    //    ns.printf(`Hack Skill: %d`, hackSkill);
    // else keep iterating until at level 5
    

    // while hacking to level 5 I might be able to use 
    // remaining 1.1 GB RAM on n00dles to detect if / when i have leveled up
    // but RAM is limited and ns.spawn needs 2GB so I cant respawn 
    // a differnt script.
    // i think i kinda have to wait for the hacks to finish and then 
    // exec new script for next stage on home server

    // MANUALLY run getServerInfo and manually monitor/debug for now
    // BUT I cant run getServerInfo on n00dles because it needs 7GB and noodles has 4 GB

    
    ns.printf(`Time: \t%f milliseconds`, performance.now() - start);

}